use crate::robot_modules::robot_configuration_module::RobotConfigurationModule;
use crate::utils::utils_files_and_strings::prelude::*;
use crate::utils::utils_se3::implicit_dual_quaternion::ImplicitDualQuaternion;
use crate::robot_modules::link::Link;
use nalgebra::{Rotation3, Vector3, Matrix3, Quaternion, UnitQuaternion};
use std::path::Path;
use collada::document::ColladaDocument;
use xml::Xml::*;
use xml::Xml;

#[derive(Debug, Clone)]
pub struct RobotMeshInfoModule {
    _robot_name: String,
    _has_collision_base_meshes: bool,
    _has_visual_base_meshes: bool,
    _has_collision_triangle_meshes: bool,
    _has_visual_triangle_meshes: bool,
    _link_mesh_visual_offsets: Vec<Option<ImplicitDualQuaternion>> // mostly for DAE collada files, where the mesh may be shifted off center in the file, even though the origin point of the mesh is somewhere else.  E.g., the Panda DAE links.
}

impl RobotMeshInfoModule {
    pub fn new(robot_configuration_module: &RobotConfigurationModule) -> Self {
        let _robot_name = robot_configuration_module.robot_model_module.robot_name.to_string();

        let mut out_self = Self { _robot_name, _has_collision_base_meshes: false, _has_visual_base_meshes: false,
            _has_collision_triangle_meshes: false, _has_visual_triangle_meshes: false, _link_mesh_visual_offsets: Vec::new()  };

        out_self.check_and_reset_all_mesh_infos();
        out_self._set_link_mesh_visual_offsets(robot_configuration_module);

        return out_self;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    pub fn check_and_reset_all_mesh_infos(&mut self) {
        let path_to_robot_dir = get_path_to_particular_robot_directory(self._robot_name.clone());

        let path = path_to_robot_dir.clone() + "/base_meshes/collision";
        self._has_collision_base_meshes = RobotMeshInfoModule::_check_path(&path);

        let path = path_to_robot_dir.clone() + "/base_meshes/visual";
        self._has_visual_base_meshes = RobotMeshInfoModule::_check_path(&path);

        let path = path_to_robot_dir.clone() + "/autogenerated_metadata/link_triangle_meshes_collision";
        self._has_collision_triangle_meshes = RobotMeshInfoModule::_check_path(&path);

        let path = path_to_robot_dir.clone() + "/autogenerated_metadata/link_triangle_meshes_visual";
        self._has_visual_triangle_meshes = RobotMeshInfoModule::_check_path(&path);
    }

    fn _check_path(path: &String) -> bool {
        let path_exists = check_if_path_exists(path.to_string());
        if path_exists {
            let num_files = get_all_files_in_directory(path.to_string()).len();
            if num_files > 0 {
                return true;
            } else {
                delete_directory_all(path.to_string());
                return false;
            }
        } else {
            return false;
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    fn _set_link_mesh_visual_offsets(&mut self, robot_configuration_module: &RobotConfigurationModule) {
        let links = &robot_configuration_module.robot_model_module.links;
        let l = links.len();

        for i in 0..l {
            if links[i].urdf_link.visual_file_name_without_extension.is_none() { self._link_mesh_visual_offsets.push(None) }
            else {
                let filename = links[i].urdf_link.visual[0].filename.as_ref().unwrap();
                let filename_extension = get_filename_extension(filename.to_string());
                match filename_extension.as_str() {
                    "dae" => {
                        self._link_mesh_visual_offsets.push( Some(Self::_get_single_link_mesh_visual_offset_from_dae(robot_configuration_module, filename.clone())) );
                    },
                    "DAE" => {
                        self._link_mesh_visual_offsets.push( Some(Self::_get_single_link_mesh_visual_offset_from_dae(robot_configuration_module, filename.clone())) );
                    },
                    _ => { self._link_mesh_visual_offsets.push(Some(ImplicitDualQuaternion::new_identity())); }
                }
            }
        }
    }

    /*
    fn _get_single_link_mesh_visual_offset_from_dae(robot_configuration_module: &RobotConfigurationModule, filename: String) -> ImplicitDualQuaternion {
        let fp = get_path_to_particular_robot_directory(robot_configuration_module.robot_model_module.robot_name.to_string()) + "/base_meshes/visual/" + filename.as_str();
        let path = Path::new(&fp);
        let doc = ColladaDocument::from_path(&path).expect(format!("Collada file {:?} could not be parsed in robot_mesh_info_module", fp).as_str());

        let mut object_id = "".to_string();

        let o = doc.get_obj_set().unwrap().clone();
        if o.objects.len() > 0 {
            object_id = o.objects[0].id.clone();
        }
        println!("{:?}", object_id);

        let mut matrix_string = "".to_string();
        let mut string_set = false;

        let a = doc.root_element.children.clone();
        for i in 0..a.len() {
            match &a[i] {
                ElementNode(e) => {
                    if e.name == "library_visual_scenes" {
                        let a2 = &e.children;
                        for i in 0..a2.len() {
                            match &a2[i] {
                                ElementNode(e2) => {
                                    let a3 = &e2.children;
                                    for i in 0..a3.len() {
                                        match &a3[i] {
                                            ElementNode(e3) => {
                                                // let id_string = e3.attributes[&("id".to_string(), None)].clone();
                                                // println!("{:?}, {:?}, {:?}", id_string, object_name, id_string == object_name);
                                                // if !(id_string == object_name) { continue; }
                                                if e3.name == "node" {
                                                    let a4 = &e3.children;
                                                    let mut url = "".to_string();

                                                    for i in 0..a4.len() {

                                                        match &a4[i] {
                                                            ElementNode(e4) => {
                                                                let mut url = e4.attributes.get(&("url".to_string(), None));
                                                                if url.is_none() { continue; }
                                                                let url_unwrap = url.unwrap();
                                                                if url_unwrap.contains(&object_id.clone()) {
                                                                    if e4.name == "matrix" {
                                                                    let a5 = &e4.children;
                                                                    for i in 0..a5.len() {
                                                                        match &a5[i] {
                                                                            CharacterNode(s) => {
                                                                                if !string_set {
                                                                                    matrix_string = s.clone();
                                                                                    string_set = true;
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                    }
                                                                }
                                                                }
                                                            }
                                                            _ => { }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => { }
                                        }
                                    }
                                }
                                _ => { }
                            }
                        }
                    }
                }
                _ => { }
            }
        }

        let split: Vec<&str> = matrix_string.split(" ").collect();

        let mut floats = Vec::new();

        let l = split.len();
        for i in 0..l {
            let f = split[i].parse::<f64>();
            if f.is_ok() {
                floats.push(f.ok().unwrap());
            }
        }

        if !(floats.len() == 16) {
            return ImplicitDualQuaternion::new_identity();
        } else {
            let mut mat = Matrix3::new(0.,0.,0.,0.,0.,0.,0.,0.,0.);
            let mut vec = Vector3::new(0.,0.,0.);
            mat[(0,0)] = floats[0];
            mat[(0,1)] = floats[1];
            mat[(0,2)] = floats[2];
            vec[0] = floats[3];

            mat[(1,0)] = floats[4];
            mat[(1,1)] = floats[5];
            mat[(1,2)] = floats[6];
            vec[1] = floats[7];

            mat[(2,0)] = floats[8];
            mat[(2,1)] = floats[9];
            mat[(2,2)] = floats[10];
            vec[2] = floats[11];

            let quat : UnitQuaternion<f64> = UnitQuaternion::from_matrix(&mat);
            let idq = ImplicitDualQuaternion::new(quat, vec);

            return idq;
        }
    }
    */

    fn _get_single_link_mesh_visual_offset_from_dae(robot_configuration_module: &RobotConfigurationModule, filename: String) -> ImplicitDualQuaternion {
        let fp = get_path_to_particular_robot_directory(robot_configuration_module.robot_model_module.robot_name.to_string()) + "/base_meshes/visual/" + filename.as_str();
        let path = Path::new(&fp);
        let doc = ColladaDocument::from_path(&path).expect(format!("Collada file {:?} could not be parsed in robot_mesh_info_module", fp).as_str());

        let mut object_id = "".to_string();

        let o = doc.get_obj_set().unwrap().clone();
        if o.objects.len() > 0 {
            object_id = o.objects[0].id.clone();
        }

        let mut matrix_string = "".to_string();
        let mut string_set = false;

        let v1 = &doc.root_element.children;
        for a in v1 {
            if string_set { break; }
            match a {
                ElementNode(e) => {
                    if e.name == "library_visual_scenes" {
                        let v2 = &e.children;
                        for a in v2 {
                            if string_set { break; }
                            match a {
                                ElementNode(e) => {
                                    if e.name == "visual_scene" {
                                        let v3 = &e.children;
                                        for a in v3 {
                                            if string_set { break; }
                                            match a {
                                                ElementNode(e) => {
                                                    if e.name == "node" {
                                                        let v4 = &e.children;

                                                        let mut url_local = "".to_string();
                                                        let mut matrix_string_local = "".to_string();

                                                        for a in v4 {
                                                            if string_set { break; }
                                                            match a {
                                                                ElementNode(e) => {
                                                                    if e.name == "instance_geometry" {
                                                                        let url = e.attributes.get(&("url".to_string(), None));
                                                                        url_local = url.unwrap().clone();
                                                                    } else if e.name == "matrix" {
                                                                        let v5 = &e.children;
                                                                        for a in v5 {
                                                                            match a {
                                                                                CharacterNode(s) => {
                                                                                    matrix_string_local = s.clone();
                                                                                },
                                                                                _ => { }
                                                                            }
                                                                        } // end of v5 loop
                                                                    }
                                                                },
                                                                _ => { }
                                                            } // end of v4 match
                                                        } // end of v4 for loop

                                                        // make decision here
                                                        if url_local.contains(&object_id) {
                                                            matrix_string = matrix_string_local.clone();
                                                            string_set = true;
                                                        }

                                                    }
                                                } // end of v3 element node
                                                _ => { }
                                            } // end of v3 match
                                        } // end of v3 for loop
                                    }
                                } // end of v2 element node
                                _ => { }
                            } // end of v2 match
                        } // end of v2 loop
                    }
                } // end of v1 element node
                _ => { }
            } // end of v1 match
        } // end of v1 for loop

        let split: Vec<&str> = matrix_string.split(" ").collect();

        let mut floats = Vec::new();

        let l = split.len();
        for i in 0..l {
            let f = split[i].parse::<f64>();
            if f.is_ok() {
                floats.push(f.ok().unwrap());
            }
        }

        if !(floats.len() == 16) {
            return ImplicitDualQuaternion::new_identity();
        } else {
            let mut mat = Matrix3::new(0.,0.,0.,0.,0.,0.,0.,0.,0.);
            let mut vec = Vector3::new(0.,0.,0.);
            mat[(0,0)] = floats[0];
            mat[(0,1)] = floats[1];
            mat[(0,2)] = floats[2];
            vec[0] = floats[3];

            mat[(1,0)] = floats[4];
            mat[(1,1)] = floats[5];
            mat[(1,2)] = floats[6];
            vec[1] = floats[7];

            mat[(2,0)] = floats[8];
            mat[(2,1)] = floats[9];
            mat[(2,2)] = floats[10];
            vec[2] = floats[11];

            let quat : UnitQuaternion<f64> = UnitQuaternion::from_matrix(&mat);
            let idq = ImplicitDualQuaternion::new(quat, vec);

            return idq;
        }


    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    pub fn has_collision_base_meshes(&self) -> bool {
        return self._has_collision_base_meshes;
    }

    pub fn has_visual_base_meshes(&self) -> bool {
        return self._has_visual_base_meshes;
    }

    pub fn has_collision_triangle_meshes(&self) -> bool {
        return self._has_collision_triangle_meshes;
    }

    pub fn has_visual_triangle_meshes(&self) -> bool {
        return self._has_visual_triangle_meshes;
    }

    pub fn get_link_mesh_visual_offsets(&self) -> &Vec<Option<ImplicitDualQuaternion>> {
        return &self._link_mesh_visual_offsets;
    }
}