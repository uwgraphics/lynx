use crate::robot_modules::{joint::*, link::*};
use crate::utils::utils_parsing::{urdf_parsing_utils::*};
use crate::utils::utils_parsing::urdf_link::URDFLink;
use crate::utils::utils_parsing::urdf_joint::URDFJoint;
use crate::utils::utils_files_and_strings::{file_utils::*, robot_folder_utils::*};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use termion::{color, style};


#[derive(Clone, Serialize, Deserialize)]
pub struct RobotModelModule {
    pub robot_name: String,
    pub links: Vec<Link>,
    pub joints: Vec<Joint>,
    pub world_link_idx: usize, // as given by the urdf
    pub link_tree_traversal_layers: Vec<Vec<usize>>,
    pub link_tree_max_depth: usize,
    _link_name_to_idx_hashmap: HashMap<String, usize>,
    _joint_name_to_idx_hashmap: HashMap<String, usize>
}

impl RobotModelModule {
    pub fn new(robot_name: &str) -> Self {
        let json_string = read_file_contents_relative_to_robot_directory(robot_name.to_string(), "autogenerated_metadata/robot_model.json".to_string());

        if json_string.is_none() {
            let mut out_self = Self::_new_from_urdf_parsing(robot_name.to_string());
            out_self.save_robot_model_module();
            return out_self;
        }

        let out_self = serde_json::from_str(&json_string.unwrap()).unwrap();
        return out_self;
    }

    fn _new_from_urdf_parsing(robot_name: String) -> Self {
        let urdf_links = get_all_urdf_links_from_robot_name(robot_name.clone());
        let urdf_joints = get_all_urdf_joints_from_robot_name(robot_name.clone());

        let mut _link_name_to_idx_hashmap = HashMap::new();
        let mut links = Vec::new();
        let l = urdf_links.len();
        for i in 0..l {
            _link_name_to_idx_hashmap.insert( urdf_links[i].name.clone(), i );
            let new_link = Link::new(urdf_links[i].clone(), i, None, Vec::new(), None, Vec::new());
            links.push( new_link );
        }

        let mut _joint_name_to_idx_hashmap = HashMap::new();
        let mut joints = Vec::new();
        let l = urdf_joints.len();
        for i in 0..l {
            _joint_name_to_idx_hashmap.insert(urdf_joints[i].name.clone(), i);
            let new_joint = Joint::new(urdf_joints[i].clone(), i, 0, 0);
            joints.push(new_joint);
        }

        let link_tree_traversal_layers = Vec::new();

        let mut robot_model_module = Self { robot_name, links, joints, world_link_idx: usize::MAX, link_tree_traversal_layers, link_tree_max_depth: 0, _link_name_to_idx_hashmap, _joint_name_to_idx_hashmap };

        // finalize model
        robot_model_module._assign_all_link_connections_manual();
        robot_model_module._assign_all_joint_connections_manual();
        robot_model_module._set_world_link_idx_manual();
        robot_model_module.set_link_tree_traversal_info();

        return robot_model_module;
    }

    fn _assign_all_link_connections_manual(&mut self) {
        let l1 = self.links.len();
        let l2 = self.joints.len();

        for i in 0..l1 {
            for j in 0..l2 {
                if self.links[i].name == self.joints[j].urdf_joint.child_link {
                    self.links[i].preceding_link_idx = self.get_link_idx_from_name( &self.joints[j].urdf_joint.parent_link );
                    self.links[i].preceding_joint_idx = self.get_joint_idx_from_name( &self.joints[j].name );
                }

                if self.links[i].name == self.joints[j].urdf_joint.parent_link {
                    let link_idx = self.get_link_idx_from_name( &self.joints[j].urdf_joint.child_link ).unwrap() ;
                    self.links[i].children_link_idxs.push( link_idx );
                    let joint_idx = self.get_joint_idx_from_name( &self.joints[j].name).unwrap();
                    self.links[i].children_joint_idxs.push(  joint_idx  );
                }
            }
        }
    }

    fn _assign_all_joint_connections_manual(&mut self) {
        let l = self.joints.len();

        for i in 0..l {
            self.joints[i].preceding_link_idx = self.get_link_idx_from_name(  &self.joints[i].urdf_joint.parent_link  ).unwrap();
            self.joints[i].child_link_idx = self.get_link_idx_from_name(  &self.joints[i].urdf_joint.child_link  ).unwrap();
        }
    }

    fn _set_world_link_idx_manual(&mut self) {
        let l = self.links.len();
        for i in 0..l {
            if self.links[i].preceding_link_idx.is_none() {
                self.world_link_idx = i;
                return;
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    pub fn set_link_tree_traversal_info(&mut self) {
        self.link_tree_traversal_layers = Vec::new();
        self.link_tree_traversal_layers.push( vec![ self.world_link_idx ] );

        let num_links = self.links.len();
        let mut curr_layer = 1 as usize;
        loop {
            let mut change_on_this_loop = false;
            for i in 0..num_links {
                if self.links[i].preceding_link_idx.is_some() && self.links[i].active {
                    if self.link_tree_traversal_layers[curr_layer - 1].contains(&self.links[i].preceding_link_idx.unwrap()) {
                        if self.link_tree_traversal_layers.len() == curr_layer { self.link_tree_traversal_layers.push( Vec::new() ); }

                        self.link_tree_traversal_layers[curr_layer].push( i );
                        change_on_this_loop = true;
                    }
                }
            }

            if change_on_this_loop {
                curr_layer += 1;
            } else {
                self.link_tree_max_depth = self.link_tree_traversal_layers.len();
                return;
            }
        }
    }

    pub fn print_link_tree_traversal_layers_with_link_names(&self) {
        for i in 0..self.link_tree_max_depth {
            let l = self.link_tree_traversal_layers[i].len();
            print!("layer {}: ", i);
            for j in 0..l {
                let idx = self.link_tree_traversal_layers[i][j];
                print!("{}, ", self.links[idx].name);
            }
            print!("\n");
        }
    }

    pub fn print_link_order(&self) {
        let num_links = self.links.len();
        for i in 0..num_links {
            println!("{}{}link {} ---> {} {} --- active: {}", style::Bold, color::Fg(color::Blue), i, style::Reset, self.links[i].name, self.links[i].active);
        }
        println!();
    }

    pub fn get_link_idx_from_name(&self, link_name: &String) -> Option<usize> {
        let ret= self._link_name_to_idx_hashmap.get(link_name);
        if ret.is_some() {
            return Some( *ret.unwrap() );
        } else {
            return None;
        }
    }

    pub fn get_joint_idx_from_name(&self, joint_name: &String) -> Option<usize> {
        let ret= self._joint_name_to_idx_hashmap.get(joint_name);
        if ret.is_some() {
            return Some( *ret.unwrap() );
        } else {
            return None;
        }
    }

    pub fn add_to_link_hashmap(&mut self, link_name: &String, idx: usize) {
        self._link_name_to_idx_hashmap.insert(link_name.clone(), idx);
    }

    pub fn add_to_joint_hashmap(&mut self, joint_name: &String, idx: usize) {
        self._joint_name_to_idx_hashmap.insert(joint_name.clone(), idx);
    }

    pub fn save_robot_model_module(&self) {
        let serialized = serde_json::to_string(&self).unwrap();
        write_string_to_file_relative_to_robot_directory( self.robot_name.clone(), "autogenerated_metadata".to_string(), "robot_model.json".to_string(), serialized, true );
    }
}